{
  "version": 3,
  "sources": ["../../inline-style-parser/index.js", "../../style-to-object/src/index.ts", "../../style-to-js/src/utilities.ts", "../../style-to-js/src/index.ts", "../../estree-util-is-identifier-name/lib/index.js", "../../hast-util-to-jsx-runtime/lib/index.js", "../../html-url-attributes/lib/index.js", "../../react-markdown/lib/index.js", "../../remark-rehype/lib/index.js"],
  "sourcesContent": ["// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function (style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n", "import type { Declaration } from 'inline-style-parser';\nimport parse from 'inline-style-parser';\n\nexport { Declaration };\n\ninterface StyleObject {\n  [name: string]: string;\n}\n\ntype Iterator = (\n  property: string,\n  value: string,\n  declaration: Declaration,\n) => void;\n\n/**\n * Parses inline style to object.\n *\n * @param style - Inline style.\n * @param iterator - Iterator.\n * @returns - Style object or null.\n *\n * @example Parsing inline style to object:\n *\n * ```js\n * import parse from 'style-to-object';\n * parse('line-height: 42;'); // { 'line-height': '42' }\n * ```\n */\nexport default function StyleToObject(\n  style: string,\n  iterator?: Iterator,\n): StyleObject | null {\n  let styleObject: StyleObject | null = null;\n\n  if (!style || typeof style !== 'string') {\n    return styleObject;\n  }\n\n  const declarations = parse(style);\n  const hasIterator = typeof iterator === 'function';\n\n  declarations.forEach((declaration) => {\n    if (declaration.type !== 'declaration') {\n      return;\n    }\n\n    const { property, value } = declaration;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      styleObject = styleObject || {};\n      styleObject[property] = value;\n    }\n  });\n\n  return styleObject;\n}\n", "const CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;\nconst HYPHEN_REGEX = /-([a-z])/g;\nconst NO_HYPHEN_REGEX = /^[^-]+$/;\nconst VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;\nconst MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;\n\n/**\n * Checks whether to skip camelCase.\n */\nconst skipCamelCase = (property: string) =>\n  !property ||\n  NO_HYPHEN_REGEX.test(property) ||\n  CUSTOM_PROPERTY_REGEX.test(property);\n\n/**\n * Replacer that capitalizes first character.\n */\nconst capitalize = (match: string, character: string) =>\n  character.toUpperCase();\n\n/**\n * Replacer that removes beginning hyphen of vendor prefix property.\n */\nconst trimHyphen = (match: string, prefix: string) => `${prefix}-`;\n\n/**\n * CamelCase options.\n */\nexport interface CamelCaseOptions {\n  reactCompat?: boolean;\n}\n\n/**\n * CamelCases a CSS property.\n */\nexport const camelCase = (property: string, options: CamelCaseOptions = {}) => {\n  if (skipCamelCase(property)) {\n    return property;\n  }\n\n  property = property.toLowerCase();\n\n  if (options.reactCompat) {\n    // `-ms` vendor prefix should not be capitalized\n    property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);\n  } else {\n    // for non-React, remove first hyphen so vendor prefix is not capitalized\n    property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);\n  }\n\n  return property.replace(HYPHEN_REGEX, capitalize);\n};\n", "import StyleToObject from 'style-to-object';\n\nimport { camelCase, CamelCaseOptions } from './utilities';\n\ntype StyleObject = Record<string, string>;\n\ninterface StyleToJSOptions extends CamelCaseOptions {}\n\n/**\n * Parses CSS inline style to JavaScript object (camelCased).\n */\nfunction StyleToJS(style: string, options?: StyleToJSOptions): StyleObject {\n  const output: StyleObject = {};\n\n  if (!style || typeof style !== 'string') {\n    return output;\n  }\n\n  StyleToObject(style, (property, value) => {\n    // skip CSS comment\n    if (property && value) {\n      output[camelCase(property, options)] = value;\n    }\n  });\n\n  return output;\n}\n\nStyleToJS.default = StyleToJS;\n\nexport = StyleToJS;\n", "/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [jsx=false]\n *   Support JSX identifiers (default: `false`).\n */\n\nconst startRe = /[$_\\p{ID_Start}]/u\nconst contRe = /[$_\\u{200C}\\u{200D}\\p{ID_Continue}]/u\nconst contReJsx = /[-$_\\u{200C}\\u{200D}\\p{ID_Continue}]/u\nconst nameRe = /^[$_\\p{ID_Start}][$_\\u{200C}\\u{200D}\\p{ID_Continue}]*$/u\nconst nameReJsx = /^[$_\\p{ID_Start}][-$_\\u{200C}\\u{200D}\\p{ID_Continue}]*$/u\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Checks if the given code point can start an identifier.\n *\n * @param {number | undefined} code\n *   Code point to check.\n * @returns {boolean}\n *   Whether `code` can start an identifier.\n */\n// Note: `undefined` is supported so you can pass the result from `''.codePointAt`.\nexport function start(code) {\n  return code ? startRe.test(String.fromCodePoint(code)) : false\n}\n\n/**\n * Checks if the given code point can continue an identifier.\n *\n * @param {number | undefined} code\n *   Code point to check.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {boolean}\n *   Whether `code` can continue an identifier.\n */\n// Note: `undefined` is supported so you can pass the result from `''.codePointAt`.\nexport function cont(code, options) {\n  const settings = options || emptyOptions\n  const re = settings.jsx ? contReJsx : contRe\n  return code ? re.test(String.fromCodePoint(code)) : false\n}\n\n/**\n * Checks if the given value is a valid identifier name.\n *\n * @param {string} name\n *   Identifier to check.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {boolean}\n *   Whether `name` can be an identifier.\n */\nexport function name(name, options) {\n  const settings = options || emptyOptions\n  const re = settings.jsx ? nameReJsx : nameRe\n  return re.test(name)\n}\n", "/**\n * @import {Identifier, Literal, MemberExpression} from 'estree'\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\n * @import {Position} from 'unist'\n * @import {Child, Create, Field, JsxElement, State, Style} from './types.js'\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {whitespace} from 'hast-util-whitespace'\nimport {find, hastToReact, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport styleToJs from 'style-to-js'\nimport {pointStart} from 'unist-util-position'\nimport {VFileMessage} from 'vfile-message'\n\n// To do: next major: `Object.hasOwn`.\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JsxElement}\n *   JSX element.\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    assert(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsmHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = pointStart(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        assert(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        assert(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        assert(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          assert(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  try {\n    return styleToJs(value, {reactCompat: true})\n  } catch (error) {\n    if (state.ignoreInvalidStyle) {\n      return {}\n    }\n\n    const cause = /** @type {Error} */ (error)\n    const message = new VFileMessage('Cannot parse `style` attribute', {\n      ancestors: state.ancestors,\n      cause,\n      ruleId: 'style',\n      source: 'hast-util-to-jsx-runtime'\n    })\n    message.file = state.filePath || undefined\n    message.url = docs + '#cannot-parse-style-attribute'\n\n    throw message\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    assert(node, 'always a result')\n    result = node\n  } else {\n    result =\n      isIdentifierName(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {string | number} */ (result.value)\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n", "/**\n * HTML URL properties.\n *\n * Each key is a property name and each value is a list of tag names it applies\n * to or `null` if it applies to all elements.\n *\n * @type {Record<string, Array<string> | null>}\n */\nexport const urlAttributes = {\n  action: ['form'],\n  cite: ['blockquote', 'del', 'ins', 'q'],\n  data: ['object'],\n  formAction: ['button', 'input'],\n  href: ['a', 'area', 'base', 'link'],\n  icon: ['menuitem'],\n  itemId: null,\n  manifest: ['html'],\n  ping: ['a', 'area'],\n  poster: ['video'],\n  src: [\n    'audio',\n    'embed',\n    'iframe',\n    'img',\n    'input',\n    'script',\n    'source',\n    'track',\n    'video'\n  ]\n}\n", "/**\n * @import {Element, Nodes, Parents, Root} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {ComponentType, JSX, ReactElement, ReactNode} from 'react'\n * @import {Options as RemarkRehypeOptions} from 'remark-rehype'\n * @import {BuildVisitor} from 'unist-util-visit'\n * @import {PluggableList, Processor} from 'unified'\n */\n\n/**\n * @callback AllowElement\n *   Filter elements.\n * @param {Readonly<Element>} element\n *   Element to check.\n * @param {number} index\n *   Index of `element` in `parent`.\n * @param {Readonly<Parents> | undefined} parent\n *   Parent of `element`.\n * @returns {boolean | null | undefined}\n *   Whether to allow `element` (default: `false`).\n */\n\n/**\n * @typedef ExtraProps\n *   Extra fields we pass.\n * @property {Element | undefined} [node]\n *   passed when `passNode` is on.\n */\n\n/**\n * @typedef {{\n *   [Key in keyof JSX.IntrinsicElements]?: ComponentType<JSX.IntrinsicElements[Key] & ExtraProps> | keyof JSX.IntrinsicElements\n * }} Components\n *   Map tag names to components.\n */\n\n/**\n * @typedef Deprecation\n *   Deprecation.\n * @property {string} from\n *   Old field.\n * @property {string} id\n *   ID in readme.\n * @property {keyof Options} [to]\n *   New field.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {AllowElement | null | undefined} [allowElement]\n *   Filter elements (optional);\n *   `allowedElements` / `disallowedElements` is used first.\n * @property {ReadonlyArray<string> | null | undefined} [allowedElements]\n *   Tag names to allow (default: all tag names);\n *   cannot combine w/ `disallowedElements`.\n * @property {string | null | undefined} [children]\n *   Markdown.\n * @property {Components | null | undefined} [components]\n *   Map tag names to components.\n * @property {ReadonlyArray<string> | null | undefined} [disallowedElements]\n *   Tag names to disallow (default: `[]`);\n *   cannot combine w/ `allowedElements`.\n * @property {PluggableList | null | undefined} [rehypePlugins]\n *   List of rehype plugins to use.\n * @property {PluggableList | null | undefined} [remarkPlugins]\n *   List of remark plugins to use.\n * @property {Readonly<RemarkRehypeOptions> | null | undefined} [remarkRehypeOptions]\n *   Options to pass through to `remark-rehype`.\n * @property {boolean | null | undefined} [skipHtml=false]\n *   Ignore HTML in markdown completely (default: `false`).\n * @property {boolean | null | undefined} [unwrapDisallowed=false]\n *   Extract (unwrap) whatâ€™s in disallowed elements (default: `false`);\n *   normally when say `strong` is not allowed, it and itâ€™s children are dropped,\n *   with `unwrapDisallowed` the element itself is replaced by its children.\n * @property {UrlTransform | null | undefined} [urlTransform]\n *   Change URLs (default: `defaultUrlTransform`)\n */\n\n/**\n * @typedef HooksOptionsOnly\n *   Configuration specifically for {@linkcode MarkdownHooks}.\n * @property {ReactNode | null | undefined} [fallback]\n *   Content to render while the processor processing the markdown (optional).\n */\n\n/**\n * @typedef {Options & HooksOptionsOnly} HooksOptions\n *   Configuration for {@linkcode MarkdownHooks};\n *   extends the regular {@linkcode Options} with a `fallback` prop.\n */\n\n/**\n * @callback UrlTransform\n *   Transform all URLs.\n * @param {string} url\n *   URL.\n * @param {string} key\n *   Property name (example: `'href'`).\n * @param {Readonly<Element>} node\n *   Node.\n * @returns {string | null | undefined}\n *   Transformed URL (optional).\n */\n\nimport {unreachable} from 'devlop'\nimport {toJsxRuntime} from 'hast-util-to-jsx-runtime'\nimport {urlAttributes} from 'html-url-attributes'\nimport {Fragment, jsx, jsxs} from 'react/jsx-runtime'\nimport {useEffect, useState} from 'react'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport {unified} from 'unified'\nimport {visit} from 'unist-util-visit'\nimport {VFile} from 'vfile'\n\nconst changelog =\n  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'\n\n/** @type {PluggableList} */\nconst emptyPlugins = []\n/** @type {Readonly<RemarkRehypeOptions>} */\nconst emptyRemarkRehypeOptions = {allowDangerousHtml: true}\nconst safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i\n\n// Mutable because we `delete` any time itâ€™s used and a message is sent.\n/** @type {ReadonlyArray<Readonly<Deprecation>>} */\nconst deprecations = [\n  {from: 'astPlugins', id: 'remove-buggy-html-in-markdown-parser'},\n  {from: 'allowDangerousHtml', id: 'remove-buggy-html-in-markdown-parser'},\n  {\n    from: 'allowNode',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'allowElement'\n  },\n  {\n    from: 'allowedTypes',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'allowedElements'\n  },\n  {from: 'className', id: 'remove-classname'},\n  {\n    from: 'disallowedTypes',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'disallowedElements'\n  },\n  {from: 'escapeHtml', id: 'remove-buggy-html-in-markdown-parser'},\n  {from: 'includeElementIndex', id: '#remove-includeelementindex'},\n  {\n    from: 'includeNodeIndex',\n    id: 'change-includenodeindex-to-includeelementindex'\n  },\n  {from: 'linkTarget', id: 'remove-linktarget'},\n  {from: 'plugins', id: 'change-plugins-to-remarkplugins', to: 'remarkPlugins'},\n  {from: 'rawSourcePos', id: '#remove-rawsourcepos'},\n  {from: 'renderers', id: 'change-renderers-to-components', to: 'components'},\n  {from: 'source', id: 'change-source-to-children', to: 'children'},\n  {from: 'sourcePos', id: '#remove-sourcepos'},\n  {from: 'transformImageUri', id: '#add-urltransform', to: 'urlTransform'},\n  {from: 'transformLinkUri', id: '#add-urltransform', to: 'urlTransform'}\n]\n\n/**\n * Component to render markdown.\n *\n * This is a synchronous component.\n * When using async plugins,\n * see {@linkcode MarkdownAsync} or {@linkcode MarkdownHooks}.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {ReactElement}\n *   React element.\n */\nexport function Markdown(options) {\n  const processor = createProcessor(options)\n  const file = createFile(options)\n  return post(processor.runSync(processor.parse(file), file), options)\n}\n\n/**\n * Component to render markdown with support for async plugins\n * through async/await.\n *\n * Components returning promises are supported on the server.\n * For async support on the client,\n * see {@linkcode MarkdownHooks}.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {Promise<ReactElement>}\n *   Promise to a React element.\n */\nexport async function MarkdownAsync(options) {\n  const processor = createProcessor(options)\n  const file = createFile(options)\n  const tree = await processor.run(processor.parse(file), file)\n  return post(tree, options)\n}\n\n/**\n * Component to render markdown with support for async plugins through hooks.\n *\n * This uses `useEffect` and `useState` hooks.\n * Hooks run on the client and do not immediately render something.\n * For async support on the server,\n * see {@linkcode MarkdownAsync}.\n *\n * @param {Readonly<HooksOptions>} options\n *   Props.\n * @returns {ReactNode}\n *   React node.\n */\nexport function MarkdownHooks(options) {\n  const processor = createProcessor(options)\n  const [error, setError] = useState(\n    /** @type {Error | undefined} */ (undefined)\n  )\n  const [tree, setTree] = useState(/** @type {Root | undefined} */ (undefined))\n\n  useEffect(\n    function () {\n      let cancelled = false\n      const file = createFile(options)\n\n      processor.run(processor.parse(file), file, function (error, tree) {\n        if (!cancelled) {\n          setError(error)\n          setTree(tree)\n        }\n      })\n\n      /**\n       * @returns {undefined}\n       *   Nothing.\n       */\n      return function () {\n        cancelled = true\n      }\n    },\n    [\n      options.children,\n      options.rehypePlugins,\n      options.remarkPlugins,\n      options.remarkRehypeOptions\n    ]\n  )\n\n  if (error) throw error\n\n  return tree ? post(tree, options) : options.fallback\n}\n\n/**\n * Set up the `unified` processor.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {Processor<MdastRoot, MdastRoot, Root, undefined, undefined>}\n *   Result.\n */\nfunction createProcessor(options) {\n  const rehypePlugins = options.rehypePlugins || emptyPlugins\n  const remarkPlugins = options.remarkPlugins || emptyPlugins\n  const remarkRehypeOptions = options.remarkRehypeOptions\n    ? {...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions}\n    : emptyRemarkRehypeOptions\n\n  const processor = unified()\n    .use(remarkParse)\n    .use(remarkPlugins)\n    .use(remarkRehype, remarkRehypeOptions)\n    .use(rehypePlugins)\n\n  return processor\n}\n\n/**\n * Set up the virtual file.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {VFile}\n *   Result.\n */\nfunction createFile(options) {\n  const children = options.children || ''\n  const file = new VFile()\n\n  if (typeof children === 'string') {\n    file.value = children\n  } else {\n    unreachable(\n      'Unexpected value `' +\n        children +\n        '` for `children` prop, expected `string`'\n    )\n  }\n\n  return file\n}\n\n/**\n * Process the result from unified some more.\n *\n * @param {Nodes} tree\n *   Tree.\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {ReactElement}\n *   React element.\n */\nfunction post(tree, options) {\n  const allowedElements = options.allowedElements\n  const allowElement = options.allowElement\n  const components = options.components\n  const disallowedElements = options.disallowedElements\n  const skipHtml = options.skipHtml\n  const unwrapDisallowed = options.unwrapDisallowed\n  const urlTransform = options.urlTransform || defaultUrlTransform\n\n  for (const deprecation of deprecations) {\n    if (Object.hasOwn(options, deprecation.from)) {\n      unreachable(\n        'Unexpected `' +\n          deprecation.from +\n          '` prop, ' +\n          (deprecation.to\n            ? 'use `' + deprecation.to + '` instead'\n            : 'remove it') +\n          ' (see <' +\n          changelog +\n          '#' +\n          deprecation.id +\n          '> for more info)'\n      )\n    }\n  }\n\n  if (allowedElements && disallowedElements) {\n    unreachable(\n      'Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other'\n    )\n  }\n\n  visit(tree, transform)\n\n  return toJsxRuntime(tree, {\n    Fragment,\n    components,\n    ignoreInvalidStyle: true,\n    jsx,\n    jsxs,\n    passKeys: true,\n    passNode: true\n  })\n\n  /** @type {BuildVisitor<Root>} */\n  function transform(node, index, parent) {\n    if (node.type === 'raw' && parent && typeof index === 'number') {\n      if (skipHtml) {\n        parent.children.splice(index, 1)\n      } else {\n        parent.children[index] = {type: 'text', value: node.value}\n      }\n\n      return index\n    }\n\n    if (node.type === 'element') {\n      /** @type {string} */\n      let key\n\n      for (key in urlAttributes) {\n        if (\n          Object.hasOwn(urlAttributes, key) &&\n          Object.hasOwn(node.properties, key)\n        ) {\n          const value = node.properties[key]\n          const test = urlAttributes[key]\n          if (test === null || test.includes(node.tagName)) {\n            node.properties[key] = urlTransform(String(value || ''), key, node)\n          }\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      let remove = allowedElements\n        ? !allowedElements.includes(node.tagName)\n        : disallowedElements\n          ? disallowedElements.includes(node.tagName)\n          : false\n\n      if (!remove && allowElement && typeof index === 'number') {\n        remove = !allowElement(node, index, parent)\n      }\n\n      if (remove && parent && typeof index === 'number') {\n        if (unwrapDisallowed && node.children) {\n          parent.children.splice(index, 1, ...node.children)\n        } else {\n          parent.children.splice(index, 1)\n        }\n\n        return index\n      }\n    }\n  }\n}\n\n/**\n * Make a URL safe.\n *\n * @satisfies {UrlTransform}\n * @param {string} value\n *   URL.\n * @returns {string}\n *   Safe URL.\n */\nexport function defaultUrlTransform(value) {\n  // Same as:\n  // <https://github.com/micromark/micromark/blob/929275e/packages/micromark-util-sanitize-uri/dev/index.js#L34>\n  // But without the `encode` part.\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, itâ€™s relative.\n    colon === -1 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash !== -1 && colon > slash) ||\n    (questionMark !== -1 && colon > questionMark) ||\n    (numberSign !== -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    safeProtocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n", "/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Options as ToHastOptions} from 'mdast-util-to-hast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<ToHastOptions, 'file'>} Options\n *\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new hast tree.\n *   Discards result.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the hast tree.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {HastRoot}\n *   Tree (hast).\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Turn markdown into HTML.\n *\n * ##### Notes\n *\n * ###### Signature\n *\n * * if a processor is given,\n *   runs the (rehype) plugins used on it with a hast tree,\n *   then discards the result (*bridge mode*)\n * * otherwise,\n *   returns a hast tree,\n *   the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n *\n * > ðŸ‘‰ **Note**:\n * > Itâ€™s highly unlikely that you want to pass a `processor`.\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most plugins ignore `raw` nodes but two notable ones donâ€™t:\n *\n * * `rehype-stringify` also has an option `allowDangerousHtml` which will\n *   output the raw HTML.\n *   This is typically discouraged as noted by the option name but is useful if\n *   you completely trust authors\n * * `rehype-raw` can handle the raw embedded HTML strings by parsing them\n *   into standard hast nodes (`element`, `text`, etc);\n *   this is a heavy task as it needs a full HTML parser,\n *   but it is the only way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark,\n * which we follow by default.\n * They are supported by GitHub,\n * so footnotes can be enabled in markdown with `remark-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes,\n * which is hidden for sighted users but shown to assistive technology.\n * When your page is not in English,\n * you must define translated values.\n *\n * Back references use ARIA attributes,\n * but the section label itself uses a heading that is hidden with an\n * `sr-only` class.\n * To show it to sighted users,\n * define different attributes in `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem,\n * as it links footnote calls to footnote definitions on the page through `id`\n * attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isnâ€™t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * * when the node has a `value`\n *   (and doesnâ€™t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n *   see later),\n *   create a hast `text` node\n * * otherwise,\n *   create a `<div>` element (which could be changed with `data.hName`),\n *   with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Readonly<Options> | null | undefined} [options]\n *   When a processor was given,\n *   configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function remarkRehype(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      // Cast because root in -> root out.\n      const hastTree = /** @type {HastRoot} */ (\n        toHast(tree, {file, ...options})\n      )\n      await destination.run(hastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree, file) {\n    // Cast because root in -> root out.\n    // To do: in the future, disallow ` || options` fallback.\n    // With `unified-engine`, `destination` can be `undefined` but\n    // `options` will be the file set.\n    // We should not pass that as `options`.\n    return /** @type {HastRoot} */ (\n      toHast(tree, {file, ...(destination || options)})\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["start", "whitespace", "name", "jsx", "jsxs", "_", "name", "stringify", "styleToJs", "error", "tree"]
}
